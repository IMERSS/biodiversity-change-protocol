}
# Given a dataframe including beta cells with columns alpha, beta, produce a summary vector fusing their statistics
region_stats <- function (x, exp_cells, weight_vector = NULL) {
cells <- nrow(x)
searched <- nrow(x %>% filter(search_effort > 0))
if (is.null(weight_vector)) {
weight_vector = rep(1, cells)
}
# Attempt at weighted average - abandoned since Meconella prob goes high over historical
# weights <- 104 - 100 / (15.8 * x$search_effort + 1)
mu <- weighted.mean(x$mean, weight_vector)
var <- weighted.mean(x$variance, weight_vector) # Possibility is pop * mean / cells but becomes too tight
# Estimate of number of distinct populations we believe the cells can be attributed to
pops <- ifelse(exp_cells > cells, 1, cells / exp_cells)
stats <- list(cells = cells, searched = searched, pops = rv(pops), habitatSearched = rp(searched / cells))
stats <- apply_region_moments(stats, mu, var)
}
agm_to_summary <- function (accepted_grouped_merged, exp_weight, solow_prob, half_solow = TRUE) {
extinction_beta <- calc_extinction_beta_vector(prior_weight, search_weight, exp_weight, solow_prob,
accepted_grouped_merged$fringe_dist, accepted_grouped_merged$search_effort, accepted_grouped_merged$area_prop, half_solow)
accepted_summary <- assign_cell_geometry_sf(accepted_grouped_merged, galgrid) %>% bind_cols(extinction_beta) %>% mutate(extinction_prob = 1 - mean)
}
stats_to_df <- function (stats) {
# Convert list to dataframe
# Old version worked when stats was a list of vectors
# stats_df <- as.data.frame(do.call(rbind, stats)) %>% tibble::remove_rownames()
# Now when it is a list of lists attested at https://stackoverflow.com/a/68162050/1381443
stats_df <- do.call(rbind, lapply(stats, data.frame)) %>% tibble::remove_rownames()
stats_df <- stats_df %>% mutate("Population" = rownames(stats))
}
analyse_accepted <- function (thisTarget, accepted_grouped_merged, habitat_to_centres, nearest_habitat_cell_id, exp_weight, solow_prob, set_name) {
accepted_summary <- agm_to_summary(accepted_grouped_merged, exp_weight, solow_prob)
st_write(accepted_summary, str_glue("Analysis_outputs/{thisTarget}_{set_name}.shp"), driver="ESRI Shapefile", delete_dsn = TRUE)
accepted_in_historical <- nrow(accepted_summary %>% filter(assigned_community > 0 & search_effort > 0) )
historical_habitat_cells <- nrow(habitat_to_centres %>% filter(assigned_community > 0))
cat("Accepted a total of ", nrow(accepted_summary), " cells within range of valid habitat, of which ", accepted_in_historical, " lie in historical habitat\n")
writeLines(str_glue("Accepted cells are proportion {accepted_in_historical}/{historical_habitat_cells} ({round(100*accepted_in_historical/historical_habitat_cells, 2)}%) of all historical habitat\n"))
# Distance at which exponential function decays to 10% of its central height indicating lack of significant interaction
exp_dist <- -log(0.1) / exp_weight
# Number of cells enclosed in this distance
exp_cells <- exp_dist^2 / gridcell^2
stats <- tapply(accepted_summary, accepted_summary$assigned_community, region_stats, exp_cells = exp_cells)
# Produce blank regional stats so that we can plot graphs in figure xxxx
blank_agm <- accepted_grouped_merged %>% mutate(search_effort = 0)
blank_as <- agm_to_summary(blank_agm, exp_weight, solow_prob)
blank_stats <- tapply(blank_as, blank_as$assigned_community, region_stats, exp_cells = exp_cells)
blank_stats_df <- stats_to_df(blank_stats) %>% mutate("target" = thisTarget, prior_ER = rv(1 - solow_prob))
allPriorStats <<- rbind(allPriorStats, blank_stats_df)
stats_df <- stats_to_df(stats)
writeLines("Summary statistics [Population `0` represents valid habitat not part of historical habitat]:\n")
print(stats_df)
writeLines("")
blank_nohalf_as <- agm_to_summary(blank_agm, exp_weight, solow_prob, half_solow = TRUE) %>% mutate(one = 1)
regional_sr <- blank_nohalf_as %>% st_drop_geometry %>% group_by(assigned_community) %>% summarise(mean_sr = mean(1 - extinction_prob), count = sum(one)) %>% mutate(sum_sr = mean_sr / count)
regional_sr_weight <- accepted_summary %>% st_drop_geometry %>%
left_join(regional_sr, by = join_by(assigned_community)) %>%
pull(sum_sr)
# Original method of computing all stats - simply concatenates all cells together, but with weighting
allStats <- c(region_stats(accepted_summary, exp_cells, regional_sr_weight), "Population" = "all")
stats_df <- rbind(stats_df, allStats)
stats_df <- stats_df %>% mutate("target" = thisTarget, prior_ER = rv(1 - solow_prob))
}
analyse_target <- function (thisTarget, detected = FALSE) {
wg("Processing target {thisTarget}\n")
# Step 3: Historical plant records for target species
target_plant_records <- historical_sf %>% dplyr::filter(str_detect(scientificName, thisTarget))
wg("Acquired {nrow(target_plant_records)} historical records\n")
historical_centres <- target_plant_records %>% select(coordinateUncertaintyInMeters, OID) %>% group_by(geometry) %>%
summarize(across(everything(), first)) %>%
ungroup()
wg("Summarised to {nrow(historical_centres)} unique historical populations")
nearest_centres <- st_nearest_feature(habitatcells, historical_centres)
nearest_distances <- st_distance(habitatcells, historical_centres[nearest_centres,], by_element = TRUE)
# For each habitat cell map it to the nearest historical population centre together with assigned_community set if it is within the community's radius
habitat_to_centres <- data.frame(
OID = historical_centres$OID[nearest_centres],
cell_id = habitatcells$cell_id,
NEAR_DIST = as.numeric(nearest_distances),
uc = historical_centres$coordinateUncertaintyInMeters[nearest_centres]
) %>% mutate_at(vars(uc), ~replace_na(., 50)) %>% mutate(
radius = uc + gridcell * sqrt(2) / 2,
assigned_community = assign_community_vector(cell_id, NEAR_DIST, radius, OID),
fringe_dist = ifelse(assigned_community == 0, NEAR_DIST - radius, 0))
community_counts <- habitat_to_centres %>%
group_by(assigned_community) %>%
summarize(
OID = first(OID),
uc = first(uc),
count = n()
) %>% ungroup()
nc <- nrow(community_counts)
wg("Analysed historical habitat into {nc} centre{ifelse(nc == 1, '', 's')}")
for(i in 1:nrow(community_counts)) {
row <- community_counts[i,]
if (row$assigned_community != 0) {
wg("--> Community centred on record {row$OID} with radius {row$uc}m covering {row$count} habitat cells")
}
}
searchEffort <- read.csv(str_glue("Analysis_inputs/Search_Effort/Target_Summaries/{thisTarget}.csv")) %>% select(cell_id, effortId, search_effort)
#searchEffort_max <- searchEffort %>%
#  group_by(cell_id) %>%
#  slice_max(search_effort, with_ties = FALSE) %>%
#  ungroup() %>% select(cell_id, effortId, search_effort)
blank_cell_ids <- setdiff(habitatcells$cell_id, unique(searchEffort$cell_id))
blankSearchEffort = data.frame(cell_id = blank_cell_ids) %>% mutate(effortId = "prior", search_effort = 0)
allSearchEffort <- rbind(searchEffort, blankSearchEffort)
# Assign each effort cell to a historical community. Those which lie outside communities but in habitat will have OID of 0, those
# which lie outside habitat entirely will have OID of NA - but because of fringing we still want to include a few of these
effortCells <- merge(allSearchEffort, habitat_to_centres, by = "cell_id", all.x = TRUE)
effortCells_sf <- effortCells %>% assign_cell_centroids_sf(galgrid)
habitat_to_centres_sf <- assign_cell_centroids_sf(habitat_to_centres, galgrid)
# For each effort cell, what is the nearest habitat polygon to it
habitat_nearest_cells <- st_nearest_feature(effortCells_sf, habitat_to_centres_sf)
habitat_nearest_cell_distances <- as.numeric(st_distance(effortCells_sf, habitat_to_centres_sf[habitat_nearest_cells,], by_element = TRUE))
searchEffort_habitat <- effortCells %>% rename(original_cell_id = cell_id) %>% mutate(
cell_id = habitat_to_centres_sf$cell_id[habitat_nearest_cells],
#          fringe_dist = habitat_to_centres_sf$fringe_dist[habitat_nearest_cells],
nearest_habitat_distance = habitat_nearest_cell_distances,
assigned_community = habitat_to_centres_sf$assigned_community[habitat_nearest_cells])
effortCells_to_nearest_habitat = data.frame(
cell_id = effortCells$cell_id,
nearest_habitat_cell_id = habitat_to_centres_sf$cell_id[habitat_nearest_cells],
fringe_dist = habitat_to_centres_sf$fringe_dist[habitat_nearest_cells]
#nearest_habitat_distance = habitat_nearest_cell_distances
)
# Now take the original search effort and "nudge" it into the closest habitat cells
#searchEffort_habitat <- merge(x = searchEffort %>% select(cell_id, effortId, search_effort), y = effortCells_to_nearest_habitat, by = "cell_id", all.x = TRUE)
# Determine the assigned community corresponding to the target of nudge
#searchEffort_habitat <- merge(x = searchEffort_habitat, y = habitat_to_centres %>% select(cell_id, assigned_community), by.x = "nearest_habitat_cell_id", by.y = "cell_id", all.x = TRUE)
discarded <- searchEffort_habitat[searchEffort_habitat$nearest_habitat_distance > gridcell, ]
wg("Discarding {nrow(discarded)} search effort cells as greater than threshold of {gridcell}m from suitable habitat",
" for total search effort of {round(sum(discarded$search_effort), 2)}ks")
accepted <- searchEffort_habitat[searchEffort_habitat$nearest_habitat_distance <= gridcell, ]
wg("Processing {nrow(accepted)} search effort cells for total search effort of {round(sum(accepted$search_effort), 2)}ks")
# Sanity check that all "accepted" search effort is indeed assigned to some community
unassigned_accepted <- sum(is.na(accepted$assigned_community))
if (unassigned_accepted > 0) {
wg("Error in analysis - {unassigned_accepted} accepted effort cells were not assigned to a community")
stop()
}
# Produce phenology outputs for Table 1
accepted_month <- accepted %>% mutate(month = as.numeric(str_extract(effortId, "(\\d{4})-(\\d{2})", group = 2))) %>% group_by(month) %>% summarise(total_search_effort = round(sum(search_effort), 2))
accepted_month_filled <- tibble(month = 2:11) %>% left_join(accepted_month, by = "month") %>% replace(is.na(.), 0)
# Transpose so that data layout matches that in the table
amf_transpose <- as.data.frame(t(accepted_month_filled$total_search_effort))
colnames(amf_transpose) <- accepted_month_filled$month
rownames(amf_transpose) <- thisTarget
allPhenology <<- rbind(allPhenology, amf_transpose)
allAcceptedSearch <<- rbind(allAcceptedSearch, accepted)
# Actually do the "nudge" and assign all search effort from cells neighbouring habitat into those actually within it
accepted_grouped <- accepted %>%
group_by(effortId, cell_id) %>%
summarize(
search_effort = sum(search_effort)
) %>%
ungroup() %>% arrange(cell_id) %>%
left_join(habitat_to_centres %>% select(cell_id, fringe_dist, assigned_community))
# We formerly accepted just the maximum search effort for a cell
# accepted_grouped_max <- accepted_grouped %>%
#   group_by(cell_id) %>%
#   slice_max(search_effort, with_ties = FALSE) %>%
#   ungroup()
accepted_grouped_sum <- accepted_grouped %>%
group_by(cell_id) %>%
summarize(
effortId = paste(effortId, collapse = ", "),
search_effort = sum(search_effort, na.rm = TRUE),
fringe_dist = first(fringe_dist),  # Assuming fringe_dist and assigned_community don't change for each cell_id
assigned_community = first(assigned_community)
) %>%
ungroup()
accepted_grouped_sf <- accepted_grouped_sum %>% assign_cell_geometry_sf(galgrid)
oneArea <- gridcell * gridcell
# Assemble the cells which truly lie within the habitat together with their proportion of overlap
effortCells_intersect <- st_intersection((accepted_grouped_sf %>% filter(search_effort > 0)), allHabitat) %>% mutate(area = st_area(.) %>% as.numeric(), area_prop = area / oneArea) %>% select(cell_id, area, area_prop) %>% st_drop_geometry()
accepted_grouped_merged <- accepted_grouped_sum %>% left_join(effortCells_intersect)
if (!detected) {
exp_weight <- (distance_exp %>% dplyr::filter(str_detect(Species, thisTarget)))$Exp_weight * exp_multiplier
solow_records <- solow_dat %>% dplyr::filter(str_detect(Species, thisTarget))
# Pick the lowest (that is, lowest "sighting rate" = greatest prob of extirpation) record, corresponding to 1958 burgman/solow value
solow_low <- min(solow_records$DirectSolowPP)
# wg("Acquired {nrow(solow_records)} Solow records with prior range between {round(solow_low, 3)} and {round(solow_high, 3)}")
lowSet <- analyse_accepted(thisTarget, accepted_grouped_merged, habitat_to_centres, nearest_habitat_cell_id, exp_weight = exp_weight, solow_prob = solow_low, set_name = "Solow_low")
return (lowSet)
}
}
allStats <- data.frame()
for (thisTarget in focalTargets) {
thisStats <- analyse_target(thisTarget)
allStats <- rbind(allStats, thisStats)
}
for (thisTarget in detectedTargets) {
analyse_target(thisTarget, TRUE)
}
write.csv(allStats, str_glue("Analysis_outputs/extirpation_statistics.csv"), na = "", row.names = FALSE)
allPhenology <- allPhenology[ order(row.names(allPhenology)), ]
write.csv(allPhenology, str_glue("Analysis_outputs/search_effort_phenology.csv"), na = "")
# Figure of (currently 728) distinct cells feeding into "Effective search efforts were thus estimated at" figure in Results of paper
allAcceptedActualSearch = allAcceptedSearch %>% filter(search_effort > 0) %>% distinct(cell_id)
allAcceptedUnique <- allAcceptedSearch %>%
group_by(cell_id, effortId) %>%
slice_head(n = 1) %>%
ungroup()
cat("Search efforts in valid habitat estimated at ", sum(allAcceptedUnique$search_effort), "ks")
allAcceptedUniqueHistorical <- allAcceptedUnique %>% filter(assigned_community != 0)
cat("Search efforts in historical habitat estimated at ", sum(allAcceptedUniqueHistorical$search_effort), "ks")
cat("Effective search efforts were estimated at ", nrow(allAcceptedActualSearch), " cells")
focalTargets
thisTarget <- focalTargets[[2]]
thisTarget <- focalTargets[[3]]
detected <- FALSE
wg("Processing target {thisTarget}\n")
# Step 3: Historical plant records for target species
target_plant_records <- historical_sf %>% dplyr::filter(str_detect(scientificName, thisTarget))
wg("Acquired {nrow(target_plant_records)} historical records\n")
historical_centres <- target_plant_records %>% select(coordinateUncertaintyInMeters, OID) %>% group_by(geometry) %>%
summarize(across(everything(), first)) %>%
ungroup()
wg("Summarised to {nrow(historical_centres)} unique historical populations")
nearest_centres <- st_nearest_feature(habitatcells, historical_centres)
nearest_distances <- st_distance(habitatcells, historical_centres[nearest_centres,], by_element = TRUE)
# For each habitat cell map it to the nearest historical population centre together with assigned_community set if it is within the community's radius
habitat_to_centres <- data.frame(
OID = historical_centres$OID[nearest_centres],
cell_id = habitatcells$cell_id,
NEAR_DIST = as.numeric(nearest_distances),
uc = historical_centres$coordinateUncertaintyInMeters[nearest_centres]
) %>% mutate_at(vars(uc), ~replace_na(., 50)) %>% mutate(
radius = uc + gridcell * sqrt(2) / 2,
assigned_community = assign_community_vector(cell_id, NEAR_DIST, radius, OID),
fringe_dist = ifelse(assigned_community == 0, NEAR_DIST - radius, 0))
community_counts <- habitat_to_centres %>%
group_by(assigned_community) %>%
summarize(
OID = first(OID),
uc = first(uc),
count = n()
) %>% ungroup()
nc <- nrow(community_counts)
wg("Analysed historical habitat into {nc} centre{ifelse(nc == 1, '', 's')}")
for(i in 1:nrow(community_counts)) {
row <- community_counts[i,]
if (row$assigned_community != 0) {
wg("--> Community centred on record {row$OID} with radius {row$uc}m covering {row$count} habitat cells")
}
}
searchEffort <- read.csv(str_glue("Analysis_inputs/Search_Effort/Target_Summaries/{thisTarget}.csv")) %>% select(cell_id, effortId, search_effort)
#searchEffort_max <- searchEffort %>%
#  group_by(cell_id) %>%
#  slice_max(search_effort, with_ties = FALSE) %>%
#  ungroup() %>% select(cell_id, effortId, search_effort)
blank_cell_ids <- setdiff(habitatcells$cell_id, unique(searchEffort$cell_id))
blankSearchEffort = data.frame(cell_id = blank_cell_ids) %>% mutate(effortId = "prior", search_effort = 0)
allSearchEffort <- rbind(searchEffort, blankSearchEffort)
# Assign each effort cell to a historical community. Those which lie outside communities but in habitat will have OID of 0, those
# which lie outside habitat entirely will have OID of NA - but because of fringing we still want to include a few of these
effortCells <- merge(allSearchEffort, habitat_to_centres, by = "cell_id", all.x = TRUE)
effortCells_sf <- effortCells %>% assign_cell_centroids_sf(galgrid)
habitat_to_centres_sf <- assign_cell_centroids_sf(habitat_to_centres, galgrid)
# For each effort cell, what is the nearest habitat polygon to it
habitat_nearest_cells <- st_nearest_feature(effortCells_sf, habitat_to_centres_sf)
habitat_nearest_cell_distances <- as.numeric(st_distance(effortCells_sf, habitat_to_centres_sf[habitat_nearest_cells,], by_element = TRUE))
searchEffort_habitat <- effortCells %>% rename(original_cell_id = cell_id) %>% mutate(
cell_id = habitat_to_centres_sf$cell_id[habitat_nearest_cells],
#          fringe_dist = habitat_to_centres_sf$fringe_dist[habitat_nearest_cells],
nearest_habitat_distance = habitat_nearest_cell_distances,
assigned_community = habitat_to_centres_sf$assigned_community[habitat_nearest_cells])
effortCells_to_nearest_habitat = data.frame(
cell_id = effortCells$cell_id,
nearest_habitat_cell_id = habitat_to_centres_sf$cell_id[habitat_nearest_cells],
fringe_dist = habitat_to_centres_sf$fringe_dist[habitat_nearest_cells]
#nearest_habitat_distance = habitat_nearest_cell_distances
)
# Now take the original search effort and "nudge" it into the closest habitat cells
#searchEffort_habitat <- merge(x = searchEffort %>% select(cell_id, effortId, search_effort), y = effortCells_to_nearest_habitat, by = "cell_id", all.x = TRUE)
# Determine the assigned community corresponding to the target of nudge
#searchEffort_habitat <- merge(x = searchEffort_habitat, y = habitat_to_centres %>% select(cell_id, assigned_community), by.x = "nearest_habitat_cell_id", by.y = "cell_id", all.x = TRUE)
discarded <- searchEffort_habitat[searchEffort_habitat$nearest_habitat_distance > gridcell, ]
wg("Discarding {nrow(discarded)} search effort cells as greater than threshold of {gridcell}m from suitable habitat",
" for total search effort of {round(sum(discarded$search_effort), 2)}ks")
accepted <- searchEffort_habitat[searchEffort_habitat$nearest_habitat_distance <= gridcell, ]
wg("Processing {nrow(accepted)} search effort cells for total search effort of {round(sum(accepted$search_effort), 2)}ks")
# Sanity check that all "accepted" search effort is indeed assigned to some community
unassigned_accepted <- sum(is.na(accepted$assigned_community))
if (unassigned_accepted > 0) {
wg("Error in analysis - {unassigned_accepted} accepted effort cells were not assigned to a community")
stop()
}
# Produce phenology outputs for Table 1
accepted_month <- accepted %>% mutate(month = as.numeric(str_extract(effortId, "(\\d{4})-(\\d{2})", group = 2))) %>% group_by(month) %>% summarise(total_search_effort = round(sum(search_effort), 2))
accepted_month_filled <- tibble(month = 2:11) %>% left_join(accepted_month, by = "month") %>% replace(is.na(.), 0)
# Transpose so that data layout matches that in the table
amf_transpose <- as.data.frame(t(accepted_month_filled$total_search_effort))
colnames(amf_transpose) <- accepted_month_filled$month
rownames(amf_transpose) <- thisTarget
allPhenology <<- rbind(allPhenology, amf_transpose)
allAcceptedSearch <<- rbind(allAcceptedSearch, accepted)
# Actually do the "nudge" and assign all search effort from cells neighbouring habitat into those actually within it
accepted_grouped <- accepted %>%
group_by(effortId, cell_id) %>%
summarize(
search_effort = sum(search_effort)
) %>%
ungroup() %>% arrange(cell_id) %>%
left_join(habitat_to_centres %>% select(cell_id, fringe_dist, assigned_community))
# We formerly accepted just the maximum search effort for a cell
# accepted_grouped_max <- accepted_grouped %>%
#   group_by(cell_id) %>%
#   slice_max(search_effort, with_ties = FALSE) %>%
#   ungroup()
accepted_grouped_sum <- accepted_grouped %>%
group_by(cell_id) %>%
summarize(
effortId = paste(effortId, collapse = ", "),
search_effort = sum(search_effort, na.rm = TRUE),
fringe_dist = first(fringe_dist),  # Assuming fringe_dist and assigned_community don't change for each cell_id
assigned_community = first(assigned_community)
) %>%
ungroup()
accepted_grouped_sf <- accepted_grouped_sum %>% assign_cell_geometry_sf(galgrid)
oneArea <- gridcell * gridcell
# Assemble the cells which truly lie within the habitat together with their proportion of overlap
effortCells_intersect <- st_intersection((accepted_grouped_sf %>% filter(search_effort > 0)), allHabitat) %>% mutate(area = st_area(.) %>% as.numeric(), area_prop = area / oneArea) %>% select(cell_id, area, area_prop) %>% st_drop_geometry()
accepted_grouped_merged <- accepted_grouped_sum %>% left_join(effortCells_intersect)
if (!detected) {
exp_weight <- (distance_exp %>% dplyr::filter(str_detect(Species, thisTarget)))$Exp_weight * exp_multiplier
solow_records <- solow_dat %>% dplyr::filter(str_detect(Species, thisTarget))
# Pick the lowest (that is, lowest "sighting rate" = greatest prob of extirpation) record, corresponding to 1958 burgman/solow value
solow_low <- min(solow_records$DirectSolowPP)
# wg("Acquired {nrow(solow_records)} Solow records with prior range between {round(solow_low, 3)} and {round(solow_high, 3)}")
lowSet <- analyse_accepted(thisTarget, accepted_grouped_merged, habitat_to_centres, nearest_habitat_cell_id, exp_weight = exp_weight, solow_prob = solow_low, set_name = "Solow_low")
return (lowSet)
}
timedWrite(accepted_grouped_merged, str_glue("Analysis_outputs/Intermediate/{thisTarget}_accepted_grouped_merged.csv"))
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
source("scripts/geomUtils.R")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
source("scripts/geomUtils.R")
source("scripts/geomUtils.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf =
source("scripts/geomUtils.R")
source("scripts/config.R")
Before the beginning of the BioGaliano project in 2015, a total of 607 vascular plant species were reported for Galiano Island, represented by 1,698 records, including 446 herbarium specimens (Fig. 1).
source("scripts/geomUtils.R")
source("scripts/config.R")
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galframe)
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
prim_sf
source("scripts/geomUtils.R")
source("scripts/config.R")
source("scripts/geomUtils.R")
source("scripts/config.R")
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = prim_sf$search_effort)
source("scripts/geomUtils.R")
source("scripts/config.R")
library(leaflet)
source("scripts/geomUtils.R")
source("scripts/config.R")
library(leaflet)
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = prim_sf$search_effort)
m <- leaflet() %>%
# Add a Tiles layer to the map
addTiles() %>%
# Add the grid layer to the map
addPolygons(data = prim_sf, fillColor = ~pal(search_effort), fillOpacity = 0.8,
color = "#BDBDC3", weight = 1) %>%
# Add a legend
addLegend(pal = pal, values = ~search_effort, opacity = 0.8, title = "Accumulated Search Effort")
pal
pal(0)
pal(0.1)
prim_sf$search_effort
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = prim_sf$search_effort)
m <- leaflet(data = prim_sf) %>%
# Add a Tiles layer to the map
addTiles() %>%
# Add the grid layer to the map
addPolygons(fillColor = ~pal(search_effort), fillOpacity = 0.8,
color = "#BDBDC3", weight = 1) %>%
# Add a legend
addLegend(pal = pal, values = ~search_effort, opacity = 0.8, title = "Accumulated Search Effort")
# Print the map
m
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = range(c(0, prim_sf$search_effort), na.rm = TRUE))
m <- leaflet(data = prim_sf) %>%
# Add a Tiles layer to the map
addTiles() %>%
# Add the grid layer to the map
addPolygons(fillColor = ~pal(search_effort), fillOpacity = 0.8,
color = "#BDBDC3", weight = 1) %>%
# Add a legend
addLegend(pal = pal, values = ~search_effort, opacity = 0.8, title = "Accumulated Search Effort")
# Print the map
m
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = range(c(0, prim_sf$search_effort), na.rm = TRUE))
m <- leaflet(data = prim_sf) %>%
# Add a Tiles layer to the map
addTiles() %>%
# Add the grid layer to the map
addPolygons(fillColor = ~pal(search_effort), fillOpacity = 0.8,
color = "#BDBDC3", weight = 1) %>%
# Add a legend
addLegend(pal = pal, values = values = c(0, max(prim_sf$search_effort, na.rm = TRUE)),
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = range(c(0, prim_sf$search_effort), na.rm = TRUE))
m <- leaflet(data = prim_sf) %>%
# Add a Tiles layer to the map
addTiles() %>%
# Add the grid layer to the map
addPolygons(fillColor = ~pal(search_effort), fillOpacity = 0.8,
color = "#BDBDC3", weight = 1) %>%
# Add a legend
addLegend(pal = pal, values = c(0, max(prim_sf$search_effort, na.rm = TRUE)),
opacity = 0.8, title = "Accumulated Search Effort")
# Print the map
m
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = range(c(0, prim_sf$search_effort), na.rm = TRUE))
m <- leaflet(data = prim_sf) %>%
# Add a Tiles layer to the map
addTiles() %>%
# Add the grid layer to the map
addPolygons(fillColor = ~pal(search_effort), fillOpacity = 0.8,
color = "#BDBDC3", weight = 1) %>%
# Add a legend
addLegend(pal = pal, values = c(0, max(prim_sf$search_effort, na.rm = TRUE)),
opacity = 0.8, title = "Accumulated Search Effort in ks")
# Print the map
m
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
source("scripts/geomUtils.R")
source("scripts/config.R")
library(leaflet)
source("scripts/geomUtils.R")
source("scripts/config.R")
prim_agm <- read.csv("Analysis_outputs/Intermediate/Primula pauciflora_accepted_grouped_merged.csv")
prim_historical <- prim_agm %>% filter(assigned_community == 77)
prim_sf = assign_cell_geometry_sf(prim_historical, galgrid)
pal <- colorNumeric(palette = "viridis", domain = range(c(0, prim_sf$search_effort), na.rm = TRUE))
m <- leaflet(data = prim_sf) %>%
# Add a Tiles layer to the map
addTiles() %>%
# Add the grid layer to the map
addPolygons(fillColor = ~pal(search_effort), fillOpacity = 0.8,
color = "#BDBDC3", weight = 1) %>%
# Add a legend
addLegend(pal = pal, values = c(0, max(prim_sf$search_effort, na.rm = TRUE)),
opacity = 0.8, title = "Accumulated Search Effort in ks")
# Print the map
m
source("scripts/geomUtils.R")
source("scripts/config.R")
library(leaflet)
blogdown::install_hugo("0.147.8")
rmarkdown::render_site(encoding = 'UTF-8', quiet = FALSE)
Sys.getenv("PATH")
Sys.getenv("PATH")
node
blogdown::serve_site()
remove.packages("stats")
.libPaths
.libPaths()
Sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
blogdown::serve_site()
library(xfun)
